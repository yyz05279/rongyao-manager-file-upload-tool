# 中文序号区域解析修复说明

## 修复日期

2025 年 10 月 23 日

## 问题描述

用户反馈"各工种工作汇报"选项卡中混入了其他区域的数据：

- 显示了机械租赁的表格标题
- 显示了"四"（问题反馈的标题）
- 显示了问题反馈的内容

问题表现为：在"各工种工作汇报（二）"选项卡中看到了本应在其他选项卡的数据。

## 根本原因

Excel 使用**中文序号**（二、三、四）作为大区域标题，但解析代码没有检测这些区域分隔符，导致：

1. **行号范围固定**：使用固定的起止行号无法适应 Excel 结构变化
2. **缺少边界检测**：没有检测中文标题行（二、三、四）
3. **数据溢出**：一个区域的解析会读取到下一个区域的数据

### Excel 实际结构

```
行号 | 序号 | 内容
-----|------|-----
...  | 2.3  | 针对缓冲罐的基础修复方案
22   | 二   | 各工种工作汇报 ← 区域标题
23   | 序号 | 姓名 | 工种...  ← 表头
24   | 1    | 张亚伟 | 电工...
...
35   | 三   | 机械租赁情况 ← 区域标题
36   | 序号 | 机械名称...  ← 表头
37   | 1    | 吊车 | ...
...
45   | 四   | 问题反馈 ← 区域标题
46   | 1    | 问题描述 ← 子标题
47   | 1.1  | 现场管道安装...
...
55   | 2    | 需求描述 ← 子标题
56   | 2.1  | ...
```

## 修复方案

### 核心思路

**区域标题检测 + 自动边界识别**

每个解析方法：

1. 扫描更大的行号范围
2. 检测目标区域的标题行（二、三、四）
3. 只在目标区域内解析数据
4. 遇到下一个区域标题时停止

### 区域解析规则

| 区域           | 标题 | 起始标志   | 终止标志   |
| -------------- | ---- | ---------- | ---------- |
| 各工种工作汇报 | 二   | 检测到"二" | 检测到"三" |
| 机械租赁情况   | 三   | 检测到"三" | 检测到"四" |
| 问题反馈       | 四   | 检测到"四" | 检测到"五" |

### 修复详情

#### 1. 各工种工作汇报（区域二）

```python
def _parse_worker_reports(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析各工种工作汇报（区域二）"""
    workers = []
    in_target_area = False  # 是否进入目标区域

    for i in range(start_row, end_row + 1):
        seq_no = self._get_cell_value(ws, i, 1)
        name = self._get_cell_value(ws, i, 2)

        # ✅ 检测区域标题
        if seq_no == '二':
            in_target_area = True
            continue  # 跳过标题行

        # ✅ 遇到下一个区域标题，停止解析
        if seq_no in ['三', '四', '五'] and in_target_area:
            break

        # ✅ 只在目标区域内解析数据
        if not in_target_area:
            continue

        # ✅ 跳过表头行
        if name in ['姓名', '序号']:
            continue

        # 解析数据...
        if name:
            workers.append({...})

    return workers
```

**调用方式**：

```python
# 从第20行开始扫描，自动检测"二"区域
report_data["workerReports"] = self._parse_worker_reports(ws, start_row=20, end_row=70)
```

#### 2. 机械租赁情况（区域三）

```python
def _parse_machinery_rentals(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析机械租赁情况（区域三）"""
    machinery = []
    in_target_area = False  # 是否进入目标区域

    for i in range(start_row, end_row + 1):
        seq_no = self._get_cell_value(ws, i, 1)
        machine_name = self._get_cell_value(ws, i, 2)

        # ✅ 检测区域标题
        if seq_no == '三':
            in_target_area = True
            continue

        # ✅ 遇到下一个区域标题，停止解析
        if seq_no in ['四', '五', '六'] and in_target_area:
            break

        # ✅ 只在目标区域内解析数据
        if not in_target_area:
            continue

        # ✅ 跳过表头行
        if machine_name in ['机械名称', '序号']:
            continue

        # 解析数据...
        if machine_name:
            machinery.append({...})

    return machinery
```

**调用方式**：

```python
# 从第20行开始扫描，自动检测"三"区域
report_data["machineryRentals"] = self._parse_machinery_rentals(ws, start_row=20, end_row=70)
```

#### 3. 问题反馈（区域四 -> 序号 1.x）

```python
def _parse_problem_feedbacks(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析问题反馈（区域四 -> 序号1.x）"""
    problems = []
    in_target_area = False

    for i in range(start_row, end_row + 1):
        problem_no = self._get_cell_value(ws, i, 1)
        description = self._get_cell_value(ws, i, 2)

        # ✅ 检测区域标题
        if problem_no == '四':
            in_target_area = True
            continue

        # ✅ 遇到下一个区域标题，停止解析
        if problem_no in ['五', '六'] and in_target_area:
            break

        # ✅ 只在目标区域内解析数据
        if not in_target_area:
            continue

        # ✅ 跳过表头行和子标题行
        if description in ['问题描述', '问题反馈', '序号']:
            continue

        # 解析数据（只保留序号1.x）
        if description and problem_no.startswith("1."):
            problems.append({...})

    return problems
```

**调用方式**：

```python
# 从第20行开始扫描，自动检测"四"区域，只保留序号1.x
report_data["problemFeedbacks"] = self._parse_problem_feedbacks(ws, start_row=20, end_row=80)
```

#### 4. 需求描述（区域四 -> 序号 2.x）

```python
def _parse_requirements(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析需求描述（区域四 -> 序号2.x）"""
    requirements = []
    in_target_area = False

    for i in range(start_row, end_row + 1):
        req_no = self._get_cell_value(ws, i, 1)
        description = self._get_cell_value(ws, i, 2)

        # ✅ 检测区域标题
        if req_no == '四':
            in_target_area = True
            continue

        # ✅ 遇到下一个区域标题，停止解析
        if req_no in ['五', '六'] and in_target_area:
            break

        # ✅ 只在目标区域内解析数据
        if not in_target_area:
            continue

        # ✅ 跳过表头行和子标题行
        if description in ['需求描述', '问题反馈', '序号']:
            continue

        # 解析数据（只保留序号2.x）
        if description and req_no.startswith("2."):
            requirements.append({...})

    return requirements
```

**调用方式**：

```python
# 从第20行开始扫描，自动检测"四"区域，只保留序号2.x
report_data["requirements"] = self._parse_requirements(ws, start_row=20, end_row=80)
```

## 修复效果

### 修复前

```
👷 各工种工作汇报（二）选项卡：
序号    姓名      工种
1       张亚伟    电工
2       魏仟金    焊工
三      ❌ 不应该出现
序号    机械名称  ❌ 不应该出现
1       吊车      ❌ 不应该出现
四      问题反馈  ❌ 不应该出现
1       问题描述  ❌ 不应该出现
```

### 修复后

```
👷 各工种工作汇报（二）选项卡：
序号    姓名      工种
1       张亚伟    电工
2       魏仟金    焊工
...

🚜 机械租赁情况（三）选项卡：
序号    机械名称
1       吊车
...

⚠️ 问题反馈（四）选项卡：
1. 问题反馈
序号    问题描述
1.1     现场管道安装...

2. 需求描述
序号    需求描述
2.1     ...
```

## 技术要点

### 1. 状态机模式

使用 `in_target_area` 标志位实现状态机：

- `False`：未进入目标区域，跳过所有数据
- `True`：已进入目标区域，开始解析数据

### 2. 边界检测

三层检测机制：

1. **区域标题检测**：检测"二"、"三"、"四"等中文序号
2. **表头行过滤**：过滤"姓名"、"机械名称"等表头
3. **序号前缀过滤**：进一步过滤"1."、"2."等子区域序号

### 3. 行号范围扩大

从固定的小范围改为更大的范围：

- 原来：`start_row=41, end_row=45`（固定 5 行）
- 现在：`start_row=20, end_row=70`（扫描 50 行，自动检测边界）

### 4. 提前终止

遇到下一个区域标题时使用 `break` 提前终止循环，提高效率。

## 优势

### 1. 自适应能力强

即使 Excel 的行号结构发生变化，只要中文标题位置正确，就能正确解析。

### 2. 数据隔离清晰

每个区域只解析自己的数据，不会溢出到其他区域。

### 3. 容错性好

- 自动跳过标题行
- 自动跳过表头行
- 自动跳过空行

### 4. 可扩展性强

如果增加"五"、"六"等新区域，只需增加相应的检测逻辑。

## 修改文件

### 已修改

- `parse_daily_report_excel.py` - Excel 解析器

### 修改方法

- `_parse_worker_reports()` - 增加区域"二"检测
- `_parse_machinery_rentals()` - 增加区域"三"检测
- `_parse_problem_feedbacks()` - 增加区域"四"检测 + 序号"1."过滤
- `_parse_requirements()` - 增加区域"四"检测 + 序号"2."过滤

### 调用逻辑变更

```python
# 原来：固定的小范围
workerReports: start_row=23, end_row=38
machineryRentals: start_row=41, end_row=45

# 现在：扩大范围 + 自动边界检测
workerReports: start_row=20, end_row=70, 自动检测"二"区域
machineryRentals: start_row=20, end_row=70, 自动检测"三"区域
problemFeedbacks: start_row=20, end_row=80, 自动检测"四"区域+序号"1."
requirements: start_row=20, end_row=80, 自动检测"四"区域+序号"2."
```

## 测试建议

1. **验证区域隔离**

   - 检查"各工种工作汇报"选项卡只显示人员数据
   - 检查"机械租赁情况"选项卡只显示机械数据
   - 检查"问题反馈"选项卡只显示问题和需求

2. **验证边界检测**

   - 确认中文标题行（二、三、四）被正确识别
   - 确认表头行被正确跳过
   - 确认数据不会溢出到其他区域

3. **验证数据完整性**

   - 确认所有人员数据都被解析
   - 确认所有机械数据都被解析
   - 确认所有问题和需求都被解析

4. **边界情况测试**
   - 测试某个区域为空的情况
   - 测试中文标题行位置变化的情况
   - 测试数据行数变化的情况

## 与之前修复的关系

### 第一次修复（数据分组过滤）

- **问题**：进度汇报和明日计划混在一起
- **方案**：增加序号前缀过滤（2.x, 3.x）

### 第二次修复（中文区域解析）

- **问题**：工作汇报、机械租赁、问题反馈混在一起
- **方案**：增加中文区域标题检测（二、三、四）

### 组合效果

现在的解析逻辑具备**双重过滤机制**：

1. **中文区域过滤**：确保只在目标大区域内解析
2. **序号前缀过滤**：确保只解析目标子区域的数据

## 后续优化建议

1. **日志增强**

   - 记录检测到的区域标题位置
   - 记录解析的起止行号
   - 方便调试和问题排查

2. **配置化**

   - 将区域标题（二、三、四）配置化
   - 支持不同的 Excel 模板变体

3. **异常检测**

   - 检测缺失的区域标题
   - 检测重复的区域标题
   - 给出友好的错误提示

4. **性能优化**
   - 记录已检测到的区域边界
   - 避免重复扫描相同的行
