# 数据分组过滤修复说明

## 修复日期

2025 年 10 月 23 日

## 问题描述

用户反馈"明日工作计划"和"进度汇报"数据混在一起展示，导致：

- 在"逐项进度汇报"选项卡中出现了序号"3"（明日工作计划标题）
- 在"逐项进度汇报"选项卡中出现了序号"3.1"（明日工作计划内容）

## 根本原因

Excel 解析时，虽然设置了不同的行号范围，但没有根据**序号前缀**进行过滤，导致不同区域的数据混在一起。

### Excel 数据结构

```
行号 | 序号 | 内容
-----|------|-----
6    | 2.1  | 面试劳务人员5人
7    | 2.2  | 催劳务公司继续招人
8    | 2.3  | 针对缓冲罐的基础修复方案及解决时间
...
12   | 3    | 明天工作计划（标题行）
13   | 3.1  | 催促杨涛...
```

### 原来的解析逻辑

```python
# 解析逐项进度汇报 (第6行开始)
report_data["taskProgressList"] = self._parse_task_progress(ws, start_row=6, end_row=12)

# 解析明天工作计划 (第15行开始)
report_data["tomorrowPlans"] = self._parse_tomorrow_plans(ws, start_row=15, end_row=20)
```

**问题**：

1. 行号范围不精确，可能遗漏数据或重叠
2. 没有根据序号前缀过滤，导致错误分组

## 修复方案

### 核心思路

**扩大行号范围 + 序号前缀过滤**

1. 让两个解析方法扫描同一个更大的范围
2. 在解析方法内部根据序号前缀进行精确过滤

### 修复内容

#### 1. 逐项进度汇报（序号 2.x）

```python
def _parse_task_progress(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析逐项进度汇报（序号2.x）"""
    tasks = []
    for i in range(start_row, end_row + 1):
        task_no = self._get_cell_value(ws, i, 1)
        task_name = self._get_cell_value(ws, i, 2)
        # ...

        # ✅ 只保存有内容且序号以"2."开头的任务
        if task_name and task_no.startswith("2."):
            tasks.append({...})
    return tasks
```

**调用方式**：

```python
# 扩大范围到第6-20行，由序号前缀进行过滤
report_data["taskProgressList"] = self._parse_task_progress(ws, start_row=6, end_row=20)
```

#### 2. 明日工作计划（序号 3.x）

```python
def _parse_tomorrow_plans(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析明天工作计划（序号3.x）"""
    plans = []
    for i in range(start_row, end_row + 1):
        plan_no = self._get_cell_value(ws, i, 1)
        task_name = self._get_cell_value(ws, i, 2)
        # ...

        # ✅ 只保存有内容且序号以"3."开头的计划
        if task_name and plan_no.startswith("3."):
            plans.append({...})
    return plans
```

**调用方式**：

```python
# 同样扫描第6-20行，由序号前缀进行过滤
report_data["tomorrowPlans"] = self._parse_tomorrow_plans(ws, start_row=6, end_row=20)
```

#### 3. 问题反馈（序号 1.x）

```python
def _parse_problem_feedbacks(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析问题反馈（序号1.x）"""
    problems = []
    for i in range(start_row, end_row + 1):
        problem_no = self._get_cell_value(ws, i, 1)
        description = self._get_cell_value(ws, i, 2)
        # ...

        # ✅ 只保存有问题描述且序号以"1."开头的记录
        if description and problem_no.startswith("1."):
            problems.append({...})
    return problems
```

**调用方式**：

```python
# 扩大范围到第48-65行
report_data["problemFeedbacks"] = self._parse_problem_feedbacks(ws, start_row=48, end_row=65)
```

#### 4. 需求描述（序号 2.x）

```python
def _parse_requirements(self, ws, start_row: int, end_row: int) -> List[Dict]:
    """解析需求描述（序号2.x）"""
    requirements = []
    for i in range(start_row, end_row + 1):
        req_no = self._get_cell_value(ws, i, 1)
        description = self._get_cell_value(ws, i, 2)
        # ...

        # ✅ 只保存有需求描述且序号以"2."开头的记录
        if description and req_no.startswith("2."):
            requirements.append({...})
    return requirements
```

**调用方式**：

```python
# 同样扫描第48-65行，由序号前缀进行过滤
report_data["requirements"] = self._parse_requirements(ws, start_row=48, end_row=65)
```

## 修复效果

### 修复前

```
📋 逐项进度汇报（序号2）选项卡：
序号    任务名称
2.1     面试劳务人员5人
2.2     催劳务公司继续招人
2.3     针对缓冲罐的基础修复方案及解决时间
3       明天工作计划 ❌ 不应该出现
3.1     催促杨涛联系... ❌ 不应该出现
```

### 修复后

```
📋 逐项进度汇报（序号2）选项卡：
序号    任务名称
2.1     面试劳务人员5人
2.2     催劳务公司继续招人
2.3     针对缓冲罐的基础修复方案及解决时间

📅 明日工作计划（序号3）选项卡：
序号    任务名称
3.1     催促杨涛联系...
```

## 序号前缀规则

| 区域         | 序号前缀 | 示例     |
| ------------ | -------- | -------- |
| 逐项进度汇报 | 2.       | 2.1, 2.2 |
| 明日工作计划 | 3.       | 3.1, 3.2 |
| 问题反馈     | 1.       | 1.1, 1.2 |
| 需求描述     | 2.       | 2.1, 2.2 |

**注意**：问题反馈区域内的"需求描述"也使用"2."前缀，但它在 Excel 的"四、问题反馈"大区域下。

## 优势

### 1. 精确过滤

通过序号前缀进行过滤，确保数据不会混淆。

### 2. 容错性强

即使 Excel 的行号结构有轻微变化，只要序号格式正确，就能正确解析。

### 3. 扩展性好

如果 Excel 增加数据行，不需要频繁调整行号范围。

### 4. 逻辑清晰

代码注释明确标识了每个方法解析的序号前缀。

## 修改文件

### 已修改

- `parse_daily_report_excel.py` - Excel 解析器

### 修改方法

- `_parse_task_progress()` - 增加"2."前缀过滤
- `_parse_tomorrow_plans()` - 增加"3."前缀过滤
- `_parse_problem_feedbacks()` - 增加"1."前缀过滤
- `_parse_requirements()` - 增加"2."前缀过滤

### 修改的调用逻辑

```python
# 原来：分散的行号范围
taskProgressList: start_row=6, end_row=12
tomorrowPlans: start_row=15, end_row=20

# 现在：共享的行号范围 + 序号前缀过滤
taskProgressList: start_row=6, end_row=20, 只保留"2."开头
tomorrowPlans: start_row=6, end_row=20, 只保留"3."开头
```

## 测试建议

1. **验证数据分离**

   - 检查"逐项进度汇报"选项卡只显示序号 2.x 的数据
   - 检查"明日工作计划"选项卡只显示序号 3.x 的数据

2. **验证完整性**

   - 确认所有 2.x 的进度汇报都被正确解析
   - 确认所有 3.x 的工作计划都被正确解析

3. **边界情况**

   - 测试标题行（如序号"3"）是否被正确过滤掉
   - 测试空行是否被正确忽略

4. **问题反馈区域**
   - 验证序号 1.x 的问题反馈正确分组
   - 验证序号 2.x 的需求描述正确分组

## 后续优化建议

1. **日志增强**

   - 在解析时记录过滤掉的行（如标题行）
   - 方便调试和问题排查

2. **配置化**

   - 将序号前缀规则配置化
   - 支持不同的 Excel 模板格式

3. **异常处理**

   - 检测序号格式异常
   - 给出友好的错误提示

4. **单元测试**
   - 为每个解析方法编写单元测试
   - 确保序号过滤逻辑正确
